$date
	Tue Oct 21 17:59:21 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module pc_tb $end
$var wire 32 ! program_counter_out [31:0] $end
$var reg 1 " branch $end
$var reg 32 # branch_target_in [31:0] $end
$var reg 1 $ clk $end
$var reg 1 % rst $end
$scope module pc $end
$var wire 1 " branch $end
$var wire 32 & branch_target [31:0] $end
$var wire 1 $ clk $end
$var wire 32 ' pc_out [31:0] $end
$var wire 1 % reset $end
$var reg 32 ( PC_reg [31:0] $end
$upscope $end
$upscope $end
$scope module tb_cpu $end
$var reg 1 ) clk $end
$var reg 1 * reset $end
$scope module mycpu $end
$var wire 1 + branch $end
$var wire 32 , branch_target [31:0] $end
$var wire 1 ) clk $end
$var wire 1 * reset $end
$var wire 1 - rst $end
$var wire 4 . reg_d [3:0] $end
$var wire 4 / reg_b [3:0] $end
$var wire 4 0 reg_a [3:0] $end
$var wire 32 1 program_counter [31:0] $end
$var wire 4 2 opcode [3:0] $end
$var wire 13 3 offset [12:0] $end
$var wire 32 4 instruction [31:0] $end
$scope module decoder $end
$var wire 4 5 reg_d [3:0] $end
$var wire 4 6 reg_b [3:0] $end
$var wire 4 7 reg_a [3:0] $end
$var wire 4 8 opcode [3:0] $end
$var wire 13 9 offset [12:0] $end
$var wire 32 : instruction [31:0] $end
$upscope $end
$scope module memory_ins $end
$var wire 32 ; instruction_out [31:0] $end
$var wire 32 < program_counter [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 + branch $end
$var wire 32 = branch_target [31:0] $end
$var wire 1 ) clk $end
$var wire 32 > pc_out [31:0] $end
$var wire 1 - reset $end
$var reg 32 ? PC_reg [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx ?
bx >
bz =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
z-
bz ,
z+
1*
0)
b0 (
b0 '
b0 &
1%
0$
b0 #
0"
b0 !
$end
#5000
b100 !
b100 '
b100 (
1)
0%
1$
#10000
0)
0$
0*
#15000
b1000 !
b1000 '
b1000 (
1)
1$
#20000
0)
0$
#25000
b1100 !
b1100 '
b1100 (
1)
1$
#30000
0)
0$
